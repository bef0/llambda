/************************************************************
 * This file is generated by typegen. Do not edit manually. *
 ************************************************************/

package io.llambda.compiler.celltype
import io.llambda

import llambda.llvmir._
import llambda.compiler.InternalCompilerErrorException
import llambda.compiler.codegen.GlobalDefines


sealed abstract class CastableValue {
  val irType: FirstClassType
  val llvmName: String

  def genPointerBitcast(block: IrBlockBuilder)(uncastValue: IrValue): IrValue =
    if (uncastValue.irType == PointerType(irType)) {
      uncastValue
    }
    else {
      block.bitcastTo(llvmName + "Cast")(uncastValue, PointerType(irType))
    }
}

sealed abstract class CellType extends CastableValue with AnyFields {
  val schemeName: String
  val directSubtypes: Set[CellType]

  lazy val concreteTypes: Set[ConcreteCellType] = this match {
    case concreteType: ConcreteCellType => Set(concreteType)
    case abstractType => directSubtypes.flatMap(_.concreteTypes)
  }

  override def toString = schemeName
}

sealed abstract class ConcreteCellType extends CellType {
  val typeId: Long
}

sealed abstract class PreconstructedCellType extends ConcreteCellType

sealed abstract class CellTypeVariant extends CastableValue

object CellType {
  val nextMetadataIndex = 97L
}

sealed trait AnyFields {
  val irType: FirstClassType

  val typeIdIrType = IntegerType(8)
  val typeIdTbaaNode: Metadata
  val typeIdGepIndices: List[Int]

  val gcStateIrType = IntegerType(8)
  val gcStateTbaaNode: Metadata
  val gcStateGepIndices: List[Int]

  def genPointerToTypeId(block: IrBlockBuilder)(valueCell: IrValue): IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("typeIdPtr")(
      elementType=typeIdIrType,
      basePointer=valueCell,
      indices=typeIdGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToTypeId(block: IrBlockBuilder)(toStore: IrValue, valueCell: IrValue, metadata: Map[String, Metadata] = Map())  {
    val typeIdPtr = genPointerToTypeId(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> typeIdTbaaNode)
    block.store(toStore, typeIdPtr, metadata=allMetadata)
  }

  def genLoadFromTypeId(block: IrBlockBuilder)(valueCell: IrValue, metadata: Map[String, Metadata] = Map()): IrValue = {
    val typeIdPtr = genPointerToTypeId(block)(valueCell)
    val allMetadata = Map("tbaa" -> typeIdTbaaNode, "invariant.load" -> GlobalDefines.emptyMetadataNode) ++ metadata
    block.load("typeId")(typeIdPtr, metadata=allMetadata)
  }

  def genPointerToGcState(block: IrBlockBuilder)(valueCell: IrValue): IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("gcStatePtr")(
      elementType=gcStateIrType,
      basePointer=valueCell,
      indices=gcStateGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToGcState(block: IrBlockBuilder)(toStore: IrValue, valueCell: IrValue, metadata: Map[String, Metadata] = Map())  {
    val gcStatePtr = genPointerToGcState(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> gcStateTbaaNode)
    block.store(toStore, gcStatePtr, metadata=allMetadata)
  }

  def genLoadFromGcState(block: IrBlockBuilder)(valueCell: IrValue, metadata: Map[String, Metadata] = Map()): IrValue = {
    val gcStatePtr = genPointerToGcState(block)(valueCell)
    val allMetadata = Map("tbaa" -> gcStateTbaaNode, "invariant.load" -> GlobalDefines.emptyMetadataNode) ++ metadata
    block.load("gcState")(gcStatePtr, metadata=allMetadata)
  }
}

object AnyCell extends CellType with AnyFields {
  val llvmName = "any"
  val irType = UserDefinedType("any")
  val schemeName = "<any>"
  val directSubtypes = Set[CellType](UnitCell, ListElementCell, StringCell, SymbolCell, BooleanCell, NumberCell, CharCell, VectorCell, BytevectorCell, RecordLikeCell, ErrorObjectCell, PortCell, EofObjectCell, MailboxCell, HashMapCell)

  val typeIdGepIndices = List(0, 0)
  val gcStateGepIndices = List(0, 1)

  val typeIdTbaaNode = NumberedMetadata(10L)
  val gcStateTbaaNode = NumberedMetadata(11L)

  def createConstant(typeId: Long): StructureConstant = {
    StructureConstant(List(
      IntegerConstant(typeIdIrType, typeId),
      IntegerConstant(gcStateIrType, 1)
    ), userDefinedType=Some(irType))
  }
}

sealed trait UnitFields extends AnyFields {
  val irType: FirstClassType
}

object UnitCell extends PreconstructedCellType with UnitFields {
  val llvmName = "unit"
  val irType = UserDefinedType("unit")
  val schemeName = "<unit>"
  val directSubtypes = Set[CellType]()

  val typeId = 1L

  val typeIdGepIndices = List(0, 0, 0)
  val gcStateGepIndices = List(0, 0, 1)

  val typeIdTbaaNode = NumberedMetadata(12L)
  val gcStateTbaaNode = NumberedMetadata(13L)
}

sealed trait ListElementFields extends AnyFields {
  val irType: FirstClassType
}

object ListElementCell extends CellType with ListElementFields {
  val llvmName = "listElement"
  val irType = UserDefinedType("listElement")
  val schemeName = "<list-element>"
  val directSubtypes = Set[CellType](PairCell, EmptyListCell)

  val typeIdGepIndices = List(0, 0, 0)
  val gcStateGepIndices = List(0, 0, 1)

  val typeIdTbaaNode = NumberedMetadata(14L)
  val gcStateTbaaNode = NumberedMetadata(15L)

  def createConstant(typeId: Long): StructureConstant = {
    StructureConstant(List(
      AnyCell.createConstant(typeId=typeId)
    ), userDefinedType=Some(irType))
  }
}

sealed trait PairFields extends ListElementFields {
  val irType: FirstClassType

  val listLengthIrType = IntegerType(32)
  val listLengthTbaaNode: Metadata
  val listLengthGepIndices: List[Int]

  val carIrType = PointerType(UserDefinedType("any"))
  val carTbaaNode: Metadata
  val carGepIndices: List[Int]

  val cdrIrType = PointerType(UserDefinedType("any"))
  val cdrTbaaNode: Metadata
  val cdrGepIndices: List[Int]

  def genPointerToListLength(block: IrBlockBuilder)(valueCell: IrValue): IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("listLengthPtr")(
      elementType=listLengthIrType,
      basePointer=valueCell,
      indices=listLengthGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToListLength(block: IrBlockBuilder)(toStore: IrValue, valueCell: IrValue, metadata: Map[String, Metadata] = Map())  {
    val listLengthPtr = genPointerToListLength(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> listLengthTbaaNode)
    block.store(toStore, listLengthPtr, metadata=allMetadata)
  }

  def genLoadFromListLength(block: IrBlockBuilder)(valueCell: IrValue, metadata: Map[String, Metadata] = Map()): IrValue = {
    val listLengthPtr = genPointerToListLength(block)(valueCell)
    val allMetadata = Map("tbaa" -> listLengthTbaaNode, "invariant.load" -> GlobalDefines.emptyMetadataNode) ++ metadata
    block.load("listLength")(listLengthPtr, metadata=allMetadata)
  }

  def genPointerToCar(block: IrBlockBuilder)(valueCell: IrValue): IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("carPtr")(
      elementType=carIrType,
      basePointer=valueCell,
      indices=carGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToCar(block: IrBlockBuilder)(toStore: IrValue, valueCell: IrValue, metadata: Map[String, Metadata] = Map())  {
    val carPtr = genPointerToCar(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> carTbaaNode)
    block.store(toStore, carPtr, metadata=allMetadata)
  }

  def genLoadFromCar(block: IrBlockBuilder)(valueCell: IrValue, metadata: Map[String, Metadata] = Map()): IrValue = {
    val carPtr = genPointerToCar(block)(valueCell)
    val allMetadata = Map("tbaa" -> carTbaaNode, "invariant.load" -> GlobalDefines.emptyMetadataNode) ++ metadata
    block.load("car")(carPtr, metadata=allMetadata)
  }

  def genPointerToCdr(block: IrBlockBuilder)(valueCell: IrValue): IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("cdrPtr")(
      elementType=cdrIrType,
      basePointer=valueCell,
      indices=cdrGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToCdr(block: IrBlockBuilder)(toStore: IrValue, valueCell: IrValue, metadata: Map[String, Metadata] = Map())  {
    val cdrPtr = genPointerToCdr(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> cdrTbaaNode)
    block.store(toStore, cdrPtr, metadata=allMetadata)
  }

  def genLoadFromCdr(block: IrBlockBuilder)(valueCell: IrValue, metadata: Map[String, Metadata] = Map()): IrValue = {
    val cdrPtr = genPointerToCdr(block)(valueCell)
    val allMetadata = Map("tbaa" -> cdrTbaaNode, "invariant.load" -> GlobalDefines.emptyMetadataNode) ++ metadata
    block.load("cdr")(cdrPtr, metadata=allMetadata)
  }
}

object PairCell extends ConcreteCellType with PairFields {
  val llvmName = "pair"
  val irType = UserDefinedType("pair")
  val schemeName = "<pair>"
  val directSubtypes = Set[CellType]()

  val typeId = 2L

  val typeIdGepIndices = List(0, 0, 0, 0)
  val gcStateGepIndices = List(0, 0, 0, 1)
  val listLengthGepIndices = List(0, 1)
  val carGepIndices = List(0, 2)
  val cdrGepIndices = List(0, 3)

  val typeIdTbaaNode = NumberedMetadata(16L)
  val gcStateTbaaNode = NumberedMetadata(17L)
  val listLengthTbaaNode = NumberedMetadata(18L)
  val carTbaaNode = NumberedMetadata(19L)
  val cdrTbaaNode = NumberedMetadata(20L)

  def createConstant(listLength: Long, car: IrConstant, cdr: IrConstant): StructureConstant = {
    if (car.irType != carIrType) {
      throw new InternalCompilerErrorException("Unexpected type for field car")
    }

    if (cdr.irType != cdrIrType) {
      throw new InternalCompilerErrorException("Unexpected type for field cdr")
    }

    StructureConstant(List(
      ListElementCell.createConstant(typeId=typeId),
      IntegerConstant(listLengthIrType, listLength),
      car,
      cdr
    ), userDefinedType=Some(irType))
  }
}

sealed trait EmptyListFields extends ListElementFields {
  val irType: FirstClassType
}

object EmptyListCell extends PreconstructedCellType with EmptyListFields {
  val llvmName = "emptyList"
  val irType = UserDefinedType("emptyList")
  val schemeName = "<empty-list>"
  val directSubtypes = Set[CellType]()

  val typeId = 3L

  val typeIdGepIndices = List(0, 0, 0, 0)
  val gcStateGepIndices = List(0, 0, 0, 1)

  val typeIdTbaaNode = NumberedMetadata(21L)
  val gcStateTbaaNode = NumberedMetadata(22L)
}

sealed trait StringFields extends AnyFields {
  val irType: FirstClassType

  val inlineByteLengthIrType = IntegerType(8)
  val inlineByteLengthTbaaNode: Metadata
  val inlineByteLengthGepIndices: List[Int]

  def genPointerToInlineByteLength(block: IrBlockBuilder)(valueCell: IrValue): IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("inlineByteLengthPtr")(
      elementType=inlineByteLengthIrType,
      basePointer=valueCell,
      indices=inlineByteLengthGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToInlineByteLength(block: IrBlockBuilder)(toStore: IrValue, valueCell: IrValue, metadata: Map[String, Metadata] = Map())  {
    val inlineByteLengthPtr = genPointerToInlineByteLength(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> inlineByteLengthTbaaNode)
    block.store(toStore, inlineByteLengthPtr, metadata=allMetadata)
  }

  def genLoadFromInlineByteLength(block: IrBlockBuilder)(valueCell: IrValue, metadata: Map[String, Metadata] = Map()): IrValue = {
    val inlineByteLengthPtr = genPointerToInlineByteLength(block)(valueCell)
    val allMetadata = Map("tbaa" -> inlineByteLengthTbaaNode, "invariant.load" -> GlobalDefines.emptyMetadataNode) ++ metadata
    block.load("inlineByteLength")(inlineByteLengthPtr, metadata=allMetadata)
  }
}

object StringCell extends ConcreteCellType with StringFields {
  val llvmName = "string"
  val irType = UserDefinedType("string")
  val schemeName = "<string>"
  val directSubtypes = Set[CellType]()

  val typeId = 4L

  val typeIdGepIndices = List(0, 0, 0)
  val gcStateGepIndices = List(0, 0, 1)
  val inlineByteLengthGepIndices = List(0, 1)

  val typeIdTbaaNode = NumberedMetadata(23L)
  val gcStateTbaaNode = NumberedMetadata(24L)
  val inlineByteLengthTbaaNode = NumberedMetadata(25L)

  def createConstant(inlineByteLength: Long): StructureConstant = {
    StructureConstant(List(
      AnyCell.createConstant(typeId=typeId),
      IntegerConstant(inlineByteLengthIrType, inlineByteLength)
    ), userDefinedType=Some(irType))
  }
}

sealed trait InlineStringFields extends StringFields {
  val irType: FirstClassType

  val inlineCharLengthIrType = IntegerType(8)
  val inlineCharLengthTbaaNode: Metadata
  val inlineCharLengthGepIndices: List[Int]

  val inlineDataIrType = ArrayType(28, IntegerType(8))
  val inlineDataTbaaNode: Metadata
  val inlineDataGepIndices: List[Int]

  def genPointerToInlineCharLength(block: IrBlockBuilder)(valueCell: IrValue): IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("inlineCharLengthPtr")(
      elementType=inlineCharLengthIrType,
      basePointer=valueCell,
      indices=inlineCharLengthGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToInlineCharLength(block: IrBlockBuilder)(toStore: IrValue, valueCell: IrValue, metadata: Map[String, Metadata] = Map())  {
    val inlineCharLengthPtr = genPointerToInlineCharLength(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> inlineCharLengthTbaaNode)
    block.store(toStore, inlineCharLengthPtr, metadata=allMetadata)
  }

  def genLoadFromInlineCharLength(block: IrBlockBuilder)(valueCell: IrValue, metadata: Map[String, Metadata] = Map()): IrValue = {
    val inlineCharLengthPtr = genPointerToInlineCharLength(block)(valueCell)
    val allMetadata = Map("tbaa" -> inlineCharLengthTbaaNode, "invariant.load" -> GlobalDefines.emptyMetadataNode) ++ metadata
    block.load("inlineCharLength")(inlineCharLengthPtr, metadata=allMetadata)
  }

  def genPointerToInlineData(block: IrBlockBuilder)(valueCell: IrValue): IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("inlineDataPtr")(
      elementType=inlineDataIrType,
      basePointer=valueCell,
      indices=inlineDataGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToInlineData(block: IrBlockBuilder)(toStore: IrValue, valueCell: IrValue, metadata: Map[String, Metadata] = Map())  {
    val inlineDataPtr = genPointerToInlineData(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> inlineDataTbaaNode)
    block.store(toStore, inlineDataPtr, metadata=allMetadata)
  }

  def genLoadFromInlineData(block: IrBlockBuilder)(valueCell: IrValue, metadata: Map[String, Metadata] = Map()): IrValue = {
    val inlineDataPtr = genPointerToInlineData(block)(valueCell)
    val allMetadata = Map("tbaa" -> inlineDataTbaaNode, "invariant.load" -> GlobalDefines.emptyMetadataNode) ++ metadata
    block.load("inlineData")(inlineDataPtr, metadata=allMetadata)
  }
}

object InlineStringCell extends CellTypeVariant with InlineStringFields {
  val llvmName = "inlineString"
  val irType = UserDefinedType("inlineString")

  val typeIdGepIndices = List(0, 0, 0, 0)
  val gcStateGepIndices = List(0, 0, 0, 1)
  val inlineByteLengthGepIndices = List(0, 0, 1)
  val inlineCharLengthGepIndices = List(0, 1)
  val inlineDataGepIndices = List(0, 2)

  val inlineCharLengthTbaaNode = NumberedMetadata(26L)
  val inlineDataTbaaNode = NumberedMetadata(27L)
  val typeIdTbaaNode = NumberedMetadata(23L)
  val gcStateTbaaNode = NumberedMetadata(24L)
  val inlineByteLengthTbaaNode = NumberedMetadata(25L)

  def createConstant(inlineCharLength: Long, inlineData: IrConstant, inlineByteLength: Long): StructureConstant = {
    if (inlineData.irType != inlineDataIrType) {
      throw new InternalCompilerErrorException("Unexpected type for field inlineData")
    }

    StructureConstant(List(
      StringCell.createConstant(inlineByteLength=inlineByteLength),
      IntegerConstant(inlineCharLengthIrType, inlineCharLength),
      inlineData
    ), userDefinedType=Some(irType))
  }
}

sealed trait HeapStringFields extends StringFields {
  val irType: FirstClassType

  val heapByteLengthIrType = IntegerType(32)
  val heapByteLengthTbaaNode: Metadata
  val heapByteLengthGepIndices: List[Int]

  val heapCharLengthIrType = IntegerType(32)
  val heapCharLengthTbaaNode: Metadata
  val heapCharLengthGepIndices: List[Int]

  val heapByteArrayIrType = PointerType(UserDefinedType("sharedByteArray"))
  val heapByteArrayTbaaNode: Metadata
  val heapByteArrayGepIndices: List[Int]

  def genPointerToHeapByteLength(block: IrBlockBuilder)(valueCell: IrValue): IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("heapByteLengthPtr")(
      elementType=heapByteLengthIrType,
      basePointer=valueCell,
      indices=heapByteLengthGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToHeapByteLength(block: IrBlockBuilder)(toStore: IrValue, valueCell: IrValue, metadata: Map[String, Metadata] = Map())  {
    val heapByteLengthPtr = genPointerToHeapByteLength(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> heapByteLengthTbaaNode)
    block.store(toStore, heapByteLengthPtr, metadata=allMetadata)
  }

  def genLoadFromHeapByteLength(block: IrBlockBuilder)(valueCell: IrValue, metadata: Map[String, Metadata] = Map()): IrValue = {
    val heapByteLengthPtr = genPointerToHeapByteLength(block)(valueCell)
    val allMetadata = Map("tbaa" -> heapByteLengthTbaaNode, "invariant.load" -> GlobalDefines.emptyMetadataNode) ++ metadata
    block.load("heapByteLength")(heapByteLengthPtr, metadata=allMetadata)
  }

  def genPointerToHeapCharLength(block: IrBlockBuilder)(valueCell: IrValue): IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("heapCharLengthPtr")(
      elementType=heapCharLengthIrType,
      basePointer=valueCell,
      indices=heapCharLengthGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToHeapCharLength(block: IrBlockBuilder)(toStore: IrValue, valueCell: IrValue, metadata: Map[String, Metadata] = Map())  {
    val heapCharLengthPtr = genPointerToHeapCharLength(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> heapCharLengthTbaaNode)
    block.store(toStore, heapCharLengthPtr, metadata=allMetadata)
  }

  def genLoadFromHeapCharLength(block: IrBlockBuilder)(valueCell: IrValue, metadata: Map[String, Metadata] = Map()): IrValue = {
    val heapCharLengthPtr = genPointerToHeapCharLength(block)(valueCell)
    val allMetadata = Map("tbaa" -> heapCharLengthTbaaNode, "invariant.load" -> GlobalDefines.emptyMetadataNode) ++ metadata
    block.load("heapCharLength")(heapCharLengthPtr, metadata=allMetadata)
  }

  def genPointerToHeapByteArray(block: IrBlockBuilder)(valueCell: IrValue): IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("heapByteArrayPtr")(
      elementType=heapByteArrayIrType,
      basePointer=valueCell,
      indices=heapByteArrayGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToHeapByteArray(block: IrBlockBuilder)(toStore: IrValue, valueCell: IrValue, metadata: Map[String, Metadata] = Map())  {
    val heapByteArrayPtr = genPointerToHeapByteArray(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> heapByteArrayTbaaNode)
    block.store(toStore, heapByteArrayPtr, metadata=allMetadata)
  }

  def genLoadFromHeapByteArray(block: IrBlockBuilder)(valueCell: IrValue, metadata: Map[String, Metadata] = Map()): IrValue = {
    val heapByteArrayPtr = genPointerToHeapByteArray(block)(valueCell)
    val allMetadata = Map("tbaa" -> heapByteArrayTbaaNode, "invariant.load" -> GlobalDefines.emptyMetadataNode) ++ metadata
    block.load("heapByteArray")(heapByteArrayPtr, metadata=allMetadata)
  }
}

object HeapStringCell extends CellTypeVariant with HeapStringFields {
  val llvmName = "heapString"
  val irType = UserDefinedType("heapString")

  val typeIdGepIndices = List(0, 0, 0, 0)
  val gcStateGepIndices = List(0, 0, 0, 1)
  val inlineByteLengthGepIndices = List(0, 0, 1)
  val heapByteLengthGepIndices = List(0, 1)
  val heapCharLengthGepIndices = List(0, 2)
  val heapByteArrayGepIndices = List(0, 3)

  val heapByteLengthTbaaNode = NumberedMetadata(28L)
  val heapCharLengthTbaaNode = NumberedMetadata(29L)
  val heapByteArrayTbaaNode = NumberedMetadata(30L)
  val typeIdTbaaNode = NumberedMetadata(23L)
  val gcStateTbaaNode = NumberedMetadata(24L)
  val inlineByteLengthTbaaNode = NumberedMetadata(25L)

  def createConstant(heapByteLength: Long, heapCharLength: Long, heapByteArray: IrConstant, inlineByteLength: Long): StructureConstant = {
    if (heapByteArray.irType != heapByteArrayIrType) {
      throw new InternalCompilerErrorException("Unexpected type for field heapByteArray")
    }

    StructureConstant(List(
      StringCell.createConstant(inlineByteLength=inlineByteLength),
      IntegerConstant(heapByteLengthIrType, heapByteLength),
      IntegerConstant(heapCharLengthIrType, heapCharLength),
      heapByteArray
    ), userDefinedType=Some(irType))
  }
}

sealed trait SymbolFields extends AnyFields {
  val irType: FirstClassType

  val inlineByteLengthIrType = IntegerType(8)
  val inlineByteLengthTbaaNode: Metadata
  val inlineByteLengthGepIndices: List[Int]

  def genPointerToInlineByteLength(block: IrBlockBuilder)(valueCell: IrValue): IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("inlineByteLengthPtr")(
      elementType=inlineByteLengthIrType,
      basePointer=valueCell,
      indices=inlineByteLengthGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToInlineByteLength(block: IrBlockBuilder)(toStore: IrValue, valueCell: IrValue, metadata: Map[String, Metadata] = Map())  {
    val inlineByteLengthPtr = genPointerToInlineByteLength(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> inlineByteLengthTbaaNode)
    block.store(toStore, inlineByteLengthPtr, metadata=allMetadata)
  }

  def genLoadFromInlineByteLength(block: IrBlockBuilder)(valueCell: IrValue, metadata: Map[String, Metadata] = Map()): IrValue = {
    val inlineByteLengthPtr = genPointerToInlineByteLength(block)(valueCell)
    val allMetadata = Map("tbaa" -> inlineByteLengthTbaaNode, "invariant.load" -> GlobalDefines.emptyMetadataNode) ++ metadata
    block.load("inlineByteLength")(inlineByteLengthPtr, metadata=allMetadata)
  }
}

object SymbolCell extends ConcreteCellType with SymbolFields {
  val llvmName = "symbol"
  val irType = UserDefinedType("symbol")
  val schemeName = "<symbol>"
  val directSubtypes = Set[CellType]()

  val typeId = 5L

  val typeIdGepIndices = List(0, 0, 0)
  val gcStateGepIndices = List(0, 0, 1)
  val inlineByteLengthGepIndices = List(0, 1)

  val typeIdTbaaNode = NumberedMetadata(31L)
  val gcStateTbaaNode = NumberedMetadata(32L)
  val inlineByteLengthTbaaNode = NumberedMetadata(33L)

  def createConstant(inlineByteLength: Long): StructureConstant = {
    StructureConstant(List(
      AnyCell.createConstant(typeId=typeId),
      IntegerConstant(inlineByteLengthIrType, inlineByteLength)
    ), userDefinedType=Some(irType))
  }
}

sealed trait InlineSymbolFields extends SymbolFields {
  val irType: FirstClassType

  val inlineCharLengthIrType = IntegerType(8)
  val inlineCharLengthTbaaNode: Metadata
  val inlineCharLengthGepIndices: List[Int]

  val inlineDataIrType = ArrayType(28, IntegerType(8))
  val inlineDataTbaaNode: Metadata
  val inlineDataGepIndices: List[Int]

  def genPointerToInlineCharLength(block: IrBlockBuilder)(valueCell: IrValue): IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("inlineCharLengthPtr")(
      elementType=inlineCharLengthIrType,
      basePointer=valueCell,
      indices=inlineCharLengthGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToInlineCharLength(block: IrBlockBuilder)(toStore: IrValue, valueCell: IrValue, metadata: Map[String, Metadata] = Map())  {
    val inlineCharLengthPtr = genPointerToInlineCharLength(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> inlineCharLengthTbaaNode)
    block.store(toStore, inlineCharLengthPtr, metadata=allMetadata)
  }

  def genLoadFromInlineCharLength(block: IrBlockBuilder)(valueCell: IrValue, metadata: Map[String, Metadata] = Map()): IrValue = {
    val inlineCharLengthPtr = genPointerToInlineCharLength(block)(valueCell)
    val allMetadata = Map("tbaa" -> inlineCharLengthTbaaNode, "invariant.load" -> GlobalDefines.emptyMetadataNode) ++ metadata
    block.load("inlineCharLength")(inlineCharLengthPtr, metadata=allMetadata)
  }

  def genPointerToInlineData(block: IrBlockBuilder)(valueCell: IrValue): IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("inlineDataPtr")(
      elementType=inlineDataIrType,
      basePointer=valueCell,
      indices=inlineDataGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToInlineData(block: IrBlockBuilder)(toStore: IrValue, valueCell: IrValue, metadata: Map[String, Metadata] = Map())  {
    val inlineDataPtr = genPointerToInlineData(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> inlineDataTbaaNode)
    block.store(toStore, inlineDataPtr, metadata=allMetadata)
  }

  def genLoadFromInlineData(block: IrBlockBuilder)(valueCell: IrValue, metadata: Map[String, Metadata] = Map()): IrValue = {
    val inlineDataPtr = genPointerToInlineData(block)(valueCell)
    val allMetadata = Map("tbaa" -> inlineDataTbaaNode, "invariant.load" -> GlobalDefines.emptyMetadataNode) ++ metadata
    block.load("inlineData")(inlineDataPtr, metadata=allMetadata)
  }
}

object InlineSymbolCell extends CellTypeVariant with InlineSymbolFields {
  val llvmName = "inlineSymbol"
  val irType = UserDefinedType("inlineSymbol")

  val typeIdGepIndices = List(0, 0, 0, 0)
  val gcStateGepIndices = List(0, 0, 0, 1)
  val inlineByteLengthGepIndices = List(0, 0, 1)
  val inlineCharLengthGepIndices = List(0, 1)
  val inlineDataGepIndices = List(0, 2)

  val inlineCharLengthTbaaNode = NumberedMetadata(34L)
  val inlineDataTbaaNode = NumberedMetadata(35L)
  val typeIdTbaaNode = NumberedMetadata(31L)
  val gcStateTbaaNode = NumberedMetadata(32L)
  val inlineByteLengthTbaaNode = NumberedMetadata(33L)

  def createConstant(inlineCharLength: Long, inlineData: IrConstant, inlineByteLength: Long): StructureConstant = {
    if (inlineData.irType != inlineDataIrType) {
      throw new InternalCompilerErrorException("Unexpected type for field inlineData")
    }

    StructureConstant(List(
      SymbolCell.createConstant(inlineByteLength=inlineByteLength),
      IntegerConstant(inlineCharLengthIrType, inlineCharLength),
      inlineData
    ), userDefinedType=Some(irType))
  }
}

sealed trait HeapSymbolFields extends SymbolFields {
  val irType: FirstClassType

  val heapByteLengthIrType = IntegerType(32)
  val heapByteLengthTbaaNode: Metadata
  val heapByteLengthGepIndices: List[Int]

  val heapCharLengthIrType = IntegerType(32)
  val heapCharLengthTbaaNode: Metadata
  val heapCharLengthGepIndices: List[Int]

  val heapByteArrayIrType = PointerType(UserDefinedType("sharedByteArray"))
  val heapByteArrayTbaaNode: Metadata
  val heapByteArrayGepIndices: List[Int]

  def genPointerToHeapByteLength(block: IrBlockBuilder)(valueCell: IrValue): IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("heapByteLengthPtr")(
      elementType=heapByteLengthIrType,
      basePointer=valueCell,
      indices=heapByteLengthGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToHeapByteLength(block: IrBlockBuilder)(toStore: IrValue, valueCell: IrValue, metadata: Map[String, Metadata] = Map())  {
    val heapByteLengthPtr = genPointerToHeapByteLength(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> heapByteLengthTbaaNode)
    block.store(toStore, heapByteLengthPtr, metadata=allMetadata)
  }

  def genLoadFromHeapByteLength(block: IrBlockBuilder)(valueCell: IrValue, metadata: Map[String, Metadata] = Map()): IrValue = {
    val heapByteLengthPtr = genPointerToHeapByteLength(block)(valueCell)
    val allMetadata = Map("tbaa" -> heapByteLengthTbaaNode, "invariant.load" -> GlobalDefines.emptyMetadataNode) ++ metadata
    block.load("heapByteLength")(heapByteLengthPtr, metadata=allMetadata)
  }

  def genPointerToHeapCharLength(block: IrBlockBuilder)(valueCell: IrValue): IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("heapCharLengthPtr")(
      elementType=heapCharLengthIrType,
      basePointer=valueCell,
      indices=heapCharLengthGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToHeapCharLength(block: IrBlockBuilder)(toStore: IrValue, valueCell: IrValue, metadata: Map[String, Metadata] = Map())  {
    val heapCharLengthPtr = genPointerToHeapCharLength(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> heapCharLengthTbaaNode)
    block.store(toStore, heapCharLengthPtr, metadata=allMetadata)
  }

  def genLoadFromHeapCharLength(block: IrBlockBuilder)(valueCell: IrValue, metadata: Map[String, Metadata] = Map()): IrValue = {
    val heapCharLengthPtr = genPointerToHeapCharLength(block)(valueCell)
    val allMetadata = Map("tbaa" -> heapCharLengthTbaaNode, "invariant.load" -> GlobalDefines.emptyMetadataNode) ++ metadata
    block.load("heapCharLength")(heapCharLengthPtr, metadata=allMetadata)
  }

  def genPointerToHeapByteArray(block: IrBlockBuilder)(valueCell: IrValue): IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("heapByteArrayPtr")(
      elementType=heapByteArrayIrType,
      basePointer=valueCell,
      indices=heapByteArrayGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToHeapByteArray(block: IrBlockBuilder)(toStore: IrValue, valueCell: IrValue, metadata: Map[String, Metadata] = Map())  {
    val heapByteArrayPtr = genPointerToHeapByteArray(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> heapByteArrayTbaaNode)
    block.store(toStore, heapByteArrayPtr, metadata=allMetadata)
  }

  def genLoadFromHeapByteArray(block: IrBlockBuilder)(valueCell: IrValue, metadata: Map[String, Metadata] = Map()): IrValue = {
    val heapByteArrayPtr = genPointerToHeapByteArray(block)(valueCell)
    val allMetadata = Map("tbaa" -> heapByteArrayTbaaNode, "invariant.load" -> GlobalDefines.emptyMetadataNode) ++ metadata
    block.load("heapByteArray")(heapByteArrayPtr, metadata=allMetadata)
  }
}

object HeapSymbolCell extends CellTypeVariant with HeapSymbolFields {
  val llvmName = "heapSymbol"
  val irType = UserDefinedType("heapSymbol")

  val typeIdGepIndices = List(0, 0, 0, 0)
  val gcStateGepIndices = List(0, 0, 0, 1)
  val inlineByteLengthGepIndices = List(0, 0, 1)
  val heapByteLengthGepIndices = List(0, 1)
  val heapCharLengthGepIndices = List(0, 2)
  val heapByteArrayGepIndices = List(0, 3)

  val heapByteLengthTbaaNode = NumberedMetadata(36L)
  val heapCharLengthTbaaNode = NumberedMetadata(37L)
  val heapByteArrayTbaaNode = NumberedMetadata(38L)
  val typeIdTbaaNode = NumberedMetadata(31L)
  val gcStateTbaaNode = NumberedMetadata(32L)
  val inlineByteLengthTbaaNode = NumberedMetadata(33L)

  def createConstant(heapByteLength: Long, heapCharLength: Long, heapByteArray: IrConstant, inlineByteLength: Long): StructureConstant = {
    if (heapByteArray.irType != heapByteArrayIrType) {
      throw new InternalCompilerErrorException("Unexpected type for field heapByteArray")
    }

    StructureConstant(List(
      SymbolCell.createConstant(inlineByteLength=inlineByteLength),
      IntegerConstant(heapByteLengthIrType, heapByteLength),
      IntegerConstant(heapCharLengthIrType, heapCharLength),
      heapByteArray
    ), userDefinedType=Some(irType))
  }
}

sealed trait BooleanFields extends AnyFields {
  val irType: FirstClassType
}

object BooleanCell extends PreconstructedCellType with BooleanFields {
  val llvmName = "boolean"
  val irType = UserDefinedType("boolean")
  val schemeName = "<boolean>"
  val directSubtypes = Set[CellType]()

  val typeId = 6L

  val typeIdGepIndices = List(0, 0, 0)
  val gcStateGepIndices = List(0, 0, 1)

  val typeIdTbaaNode = NumberedMetadata(39L)
  val gcStateTbaaNode = NumberedMetadata(40L)
}

sealed trait NumberFields extends AnyFields {
  val irType: FirstClassType
}

object NumberCell extends CellType with NumberFields {
  val llvmName = "number"
  val irType = UserDefinedType("number")
  val schemeName = "<number>"
  val directSubtypes = Set[CellType](IntegerCell, FlonumCell)

  val typeIdGepIndices = List(0, 0, 0)
  val gcStateGepIndices = List(0, 0, 1)

  val typeIdTbaaNode = NumberedMetadata(41L)
  val gcStateTbaaNode = NumberedMetadata(42L)

  def createConstant(typeId: Long): StructureConstant = {
    StructureConstant(List(
      AnyCell.createConstant(typeId=typeId)
    ), userDefinedType=Some(irType))
  }
}

sealed trait IntegerFields extends NumberFields {
  val irType: FirstClassType

  val valueIrType = IntegerType(64)
  val valueTbaaNode: Metadata
  val valueGepIndices: List[Int]

  def genPointerToValue(block: IrBlockBuilder)(valueCell: IrValue): IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("valuePtr")(
      elementType=valueIrType,
      basePointer=valueCell,
      indices=valueGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToValue(block: IrBlockBuilder)(toStore: IrValue, valueCell: IrValue, metadata: Map[String, Metadata] = Map())  {
    val valuePtr = genPointerToValue(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> valueTbaaNode)
    block.store(toStore, valuePtr, metadata=allMetadata)
  }

  def genLoadFromValue(block: IrBlockBuilder)(valueCell: IrValue, metadata: Map[String, Metadata] = Map()): IrValue = {
    val valuePtr = genPointerToValue(block)(valueCell)
    val allMetadata = Map("tbaa" -> valueTbaaNode, "invariant.load" -> GlobalDefines.emptyMetadataNode) ++ metadata
    block.load("value")(valuePtr, metadata=allMetadata)
  }
}

object IntegerCell extends ConcreteCellType with IntegerFields {
  val llvmName = "integer"
  val irType = UserDefinedType("integer")
  val schemeName = "<integer>"
  val directSubtypes = Set[CellType]()

  val typeId = 7L

  val typeIdGepIndices = List(0, 0, 0, 0)
  val gcStateGepIndices = List(0, 0, 0, 1)
  val valueGepIndices = List(0, 1)

  val typeIdTbaaNode = NumberedMetadata(43L)
  val gcStateTbaaNode = NumberedMetadata(44L)
  val valueTbaaNode = NumberedMetadata(45L)

  def createConstant(value: Long): StructureConstant = {
    StructureConstant(List(
      NumberCell.createConstant(typeId=typeId),
      IntegerConstant(valueIrType, value)
    ), userDefinedType=Some(irType))
  }
}

sealed trait FlonumFields extends NumberFields {
  val irType: FirstClassType

  val valueIrType = DoubleType
  val valueTbaaNode: Metadata
  val valueGepIndices: List[Int]

  def genPointerToValue(block: IrBlockBuilder)(valueCell: IrValue): IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("valuePtr")(
      elementType=valueIrType,
      basePointer=valueCell,
      indices=valueGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToValue(block: IrBlockBuilder)(toStore: IrValue, valueCell: IrValue, metadata: Map[String, Metadata] = Map())  {
    val valuePtr = genPointerToValue(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> valueTbaaNode)
    block.store(toStore, valuePtr, metadata=allMetadata)
  }

  def genLoadFromValue(block: IrBlockBuilder)(valueCell: IrValue, metadata: Map[String, Metadata] = Map()): IrValue = {
    val valuePtr = genPointerToValue(block)(valueCell)
    val allMetadata = Map("tbaa" -> valueTbaaNode, "invariant.load" -> GlobalDefines.emptyMetadataNode) ++ metadata
    block.load("value")(valuePtr, metadata=allMetadata)
  }
}

object FlonumCell extends ConcreteCellType with FlonumFields {
  val llvmName = "flonum"
  val irType = UserDefinedType("flonum")
  val schemeName = "<flonum>"
  val directSubtypes = Set[CellType]()

  val typeId = 8L

  val typeIdGepIndices = List(0, 0, 0, 0)
  val gcStateGepIndices = List(0, 0, 0, 1)
  val valueGepIndices = List(0, 1)

  val typeIdTbaaNode = NumberedMetadata(46L)
  val gcStateTbaaNode = NumberedMetadata(47L)
  val valueTbaaNode = NumberedMetadata(48L)

  def createConstant(value: IrConstant): StructureConstant = {
    if (value.irType != valueIrType) {
      throw new InternalCompilerErrorException("Unexpected type for field value")
    }

    StructureConstant(List(
      NumberCell.createConstant(typeId=typeId),
      value
    ), userDefinedType=Some(irType))
  }
}

sealed trait CharFields extends AnyFields {
  val irType: FirstClassType

  val unicodeCharIrType = IntegerType(32)
  val unicodeCharTbaaNode: Metadata
  val unicodeCharGepIndices: List[Int]

  def genPointerToUnicodeChar(block: IrBlockBuilder)(valueCell: IrValue): IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("unicodeCharPtr")(
      elementType=unicodeCharIrType,
      basePointer=valueCell,
      indices=unicodeCharGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToUnicodeChar(block: IrBlockBuilder)(toStore: IrValue, valueCell: IrValue, metadata: Map[String, Metadata] = Map())  {
    val unicodeCharPtr = genPointerToUnicodeChar(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> unicodeCharTbaaNode)
    block.store(toStore, unicodeCharPtr, metadata=allMetadata)
  }

  def genLoadFromUnicodeChar(block: IrBlockBuilder)(valueCell: IrValue, metadata: Map[String, Metadata] = Map()): IrValue = {
    val unicodeCharPtr = genPointerToUnicodeChar(block)(valueCell)
    val allMetadata = Map("tbaa" -> unicodeCharTbaaNode, "invariant.load" -> GlobalDefines.emptyMetadataNode) ++ metadata
    block.load("unicodeChar")(unicodeCharPtr, metadata=allMetadata)
  }
}

object CharCell extends ConcreteCellType with CharFields {
  val llvmName = "char"
  val irType = UserDefinedType("char")
  val schemeName = "<char>"
  val directSubtypes = Set[CellType]()

  val typeId = 9L

  val typeIdGepIndices = List(0, 0, 0)
  val gcStateGepIndices = List(0, 0, 1)
  val unicodeCharGepIndices = List(0, 1)

  val typeIdTbaaNode = NumberedMetadata(49L)
  val gcStateTbaaNode = NumberedMetadata(50L)
  val unicodeCharTbaaNode = NumberedMetadata(51L)

  def createConstant(unicodeChar: Long): StructureConstant = {
    StructureConstant(List(
      AnyCell.createConstant(typeId=typeId),
      IntegerConstant(unicodeCharIrType, unicodeChar)
    ), userDefinedType=Some(irType))
  }
}

sealed trait VectorFields extends AnyFields {
  val irType: FirstClassType

  val lengthIrType = IntegerType(64)
  val lengthTbaaNode: Metadata
  val lengthGepIndices: List[Int]

  val elementsIrType = PointerType(PointerType(UserDefinedType("any")))
  val elementsTbaaNode: Metadata
  val elementsGepIndices: List[Int]

  def genPointerToLength(block: IrBlockBuilder)(valueCell: IrValue): IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("lengthPtr")(
      elementType=lengthIrType,
      basePointer=valueCell,
      indices=lengthGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToLength(block: IrBlockBuilder)(toStore: IrValue, valueCell: IrValue, metadata: Map[String, Metadata] = Map())  {
    val lengthPtr = genPointerToLength(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> lengthTbaaNode)
    block.store(toStore, lengthPtr, metadata=allMetadata)
  }

  def genLoadFromLength(block: IrBlockBuilder)(valueCell: IrValue, metadata: Map[String, Metadata] = Map()): IrValue = {
    val lengthPtr = genPointerToLength(block)(valueCell)
    val allMetadata = Map("tbaa" -> lengthTbaaNode, "invariant.load" -> GlobalDefines.emptyMetadataNode) ++ metadata
    block.load("length")(lengthPtr, metadata=allMetadata)
  }

  def genPointerToElements(block: IrBlockBuilder)(valueCell: IrValue): IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("elementsPtr")(
      elementType=elementsIrType,
      basePointer=valueCell,
      indices=elementsGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToElements(block: IrBlockBuilder)(toStore: IrValue, valueCell: IrValue, metadata: Map[String, Metadata] = Map())  {
    val elementsPtr = genPointerToElements(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> elementsTbaaNode)
    block.store(toStore, elementsPtr, metadata=allMetadata)
  }

  def genLoadFromElements(block: IrBlockBuilder)(valueCell: IrValue, metadata: Map[String, Metadata] = Map()): IrValue = {
    val elementsPtr = genPointerToElements(block)(valueCell)
    val allMetadata = Map("tbaa" -> elementsTbaaNode, "invariant.load" -> GlobalDefines.emptyMetadataNode) ++ metadata
    block.load("elements")(elementsPtr, metadata=allMetadata)
  }
}

object VectorCell extends ConcreteCellType with VectorFields {
  val llvmName = "vector"
  val irType = UserDefinedType("vector")
  val schemeName = "<vector>"
  val directSubtypes = Set[CellType]()

  val typeId = 10L

  val typeIdGepIndices = List(0, 0, 0)
  val gcStateGepIndices = List(0, 0, 1)
  val lengthGepIndices = List(0, 1)
  val elementsGepIndices = List(0, 2)

  val typeIdTbaaNode = NumberedMetadata(52L)
  val gcStateTbaaNode = NumberedMetadata(53L)
  val lengthTbaaNode = NumberedMetadata(54L)
  val elementsTbaaNode = NumberedMetadata(55L)

  def createConstant(length: Long, elements: IrConstant): StructureConstant = {
    if (elements.irType != elementsIrType) {
      throw new InternalCompilerErrorException("Unexpected type for field elements")
    }

    StructureConstant(List(
      AnyCell.createConstant(typeId=typeId),
      IntegerConstant(lengthIrType, length),
      elements
    ), userDefinedType=Some(irType))
  }
}

sealed trait BytevectorFields extends AnyFields {
  val irType: FirstClassType

  val lengthIrType = IntegerType(64)
  val lengthTbaaNode: Metadata
  val lengthGepIndices: List[Int]

  val byteArrayIrType = PointerType(UserDefinedType("sharedByteArray"))
  val byteArrayTbaaNode: Metadata
  val byteArrayGepIndices: List[Int]

  def genPointerToLength(block: IrBlockBuilder)(valueCell: IrValue): IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("lengthPtr")(
      elementType=lengthIrType,
      basePointer=valueCell,
      indices=lengthGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToLength(block: IrBlockBuilder)(toStore: IrValue, valueCell: IrValue, metadata: Map[String, Metadata] = Map())  {
    val lengthPtr = genPointerToLength(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> lengthTbaaNode)
    block.store(toStore, lengthPtr, metadata=allMetadata)
  }

  def genLoadFromLength(block: IrBlockBuilder)(valueCell: IrValue, metadata: Map[String, Metadata] = Map()): IrValue = {
    val lengthPtr = genPointerToLength(block)(valueCell)
    val allMetadata = Map("tbaa" -> lengthTbaaNode, "invariant.load" -> GlobalDefines.emptyMetadataNode) ++ metadata
    block.load("length")(lengthPtr, metadata=allMetadata)
  }

  def genPointerToByteArray(block: IrBlockBuilder)(valueCell: IrValue): IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("byteArrayPtr")(
      elementType=byteArrayIrType,
      basePointer=valueCell,
      indices=byteArrayGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToByteArray(block: IrBlockBuilder)(toStore: IrValue, valueCell: IrValue, metadata: Map[String, Metadata] = Map())  {
    val byteArrayPtr = genPointerToByteArray(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> byteArrayTbaaNode)
    block.store(toStore, byteArrayPtr, metadata=allMetadata)
  }

  def genLoadFromByteArray(block: IrBlockBuilder)(valueCell: IrValue, metadata: Map[String, Metadata] = Map()): IrValue = {
    val byteArrayPtr = genPointerToByteArray(block)(valueCell)
    val allMetadata = Map("tbaa" -> byteArrayTbaaNode) ++ metadata
    block.load("byteArray")(byteArrayPtr, metadata=allMetadata)
  }
}

object BytevectorCell extends ConcreteCellType with BytevectorFields {
  val llvmName = "bytevector"
  val irType = UserDefinedType("bytevector")
  val schemeName = "<bytevector>"
  val directSubtypes = Set[CellType]()

  val typeId = 11L

  val typeIdGepIndices = List(0, 0, 0)
  val gcStateGepIndices = List(0, 0, 1)
  val lengthGepIndices = List(0, 1)
  val byteArrayGepIndices = List(0, 2)

  val typeIdTbaaNode = NumberedMetadata(56L)
  val gcStateTbaaNode = NumberedMetadata(57L)
  val lengthTbaaNode = NumberedMetadata(58L)
  val byteArrayTbaaNode = NumberedMetadata(59L)

  def createConstant(length: Long, byteArray: IrConstant): StructureConstant = {
    if (byteArray.irType != byteArrayIrType) {
      throw new InternalCompilerErrorException("Unexpected type for field byteArray")
    }

    StructureConstant(List(
      AnyCell.createConstant(typeId=typeId),
      IntegerConstant(lengthIrType, length),
      byteArray
    ), userDefinedType=Some(irType))
  }
}

sealed trait RecordLikeFields extends AnyFields {
  val irType: FirstClassType

  val dataIsInlineIrType = IntegerType(8)
  val dataIsInlineTbaaNode: Metadata
  val dataIsInlineGepIndices: List[Int]

  val isUndefinedIrType = IntegerType(8)
  val isUndefinedTbaaNode: Metadata
  val isUndefinedGepIndices: List[Int]

  val recordClassIdIrType = IntegerType(32)
  val recordClassIdTbaaNode: Metadata
  val recordClassIdGepIndices: List[Int]

  val recordDataIrType = PointerType(IntegerType(8))
  val recordDataTbaaNode: Metadata
  val recordDataGepIndices: List[Int]

  def genPointerToDataIsInline(block: IrBlockBuilder)(valueCell: IrValue): IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("dataIsInlinePtr")(
      elementType=dataIsInlineIrType,
      basePointer=valueCell,
      indices=dataIsInlineGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToDataIsInline(block: IrBlockBuilder)(toStore: IrValue, valueCell: IrValue, metadata: Map[String, Metadata] = Map())  {
    val dataIsInlinePtr = genPointerToDataIsInline(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> dataIsInlineTbaaNode)
    block.store(toStore, dataIsInlinePtr, metadata=allMetadata)
  }

  def genLoadFromDataIsInline(block: IrBlockBuilder)(valueCell: IrValue, metadata: Map[String, Metadata] = Map()): IrValue = {
    val dataIsInlinePtr = genPointerToDataIsInline(block)(valueCell)
    val allMetadata = Map("tbaa" -> dataIsInlineTbaaNode, "invariant.load" -> GlobalDefines.emptyMetadataNode) ++ metadata
    block.load("dataIsInline")(dataIsInlinePtr, metadata=allMetadata)
  }

  def genPointerToIsUndefined(block: IrBlockBuilder)(valueCell: IrValue): IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("isUndefinedPtr")(
      elementType=isUndefinedIrType,
      basePointer=valueCell,
      indices=isUndefinedGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToIsUndefined(block: IrBlockBuilder)(toStore: IrValue, valueCell: IrValue, metadata: Map[String, Metadata] = Map())  {
    val isUndefinedPtr = genPointerToIsUndefined(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> isUndefinedTbaaNode)
    block.store(toStore, isUndefinedPtr, metadata=allMetadata)
  }

  def genLoadFromIsUndefined(block: IrBlockBuilder)(valueCell: IrValue, metadata: Map[String, Metadata] = Map()): IrValue = {
    val isUndefinedPtr = genPointerToIsUndefined(block)(valueCell)
    val allMetadata = Map("tbaa" -> isUndefinedTbaaNode) ++ metadata
    block.load("isUndefined")(isUndefinedPtr, metadata=allMetadata)
  }

  def genPointerToRecordClassId(block: IrBlockBuilder)(valueCell: IrValue): IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("recordClassIdPtr")(
      elementType=recordClassIdIrType,
      basePointer=valueCell,
      indices=recordClassIdGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToRecordClassId(block: IrBlockBuilder)(toStore: IrValue, valueCell: IrValue, metadata: Map[String, Metadata] = Map())  {
    val recordClassIdPtr = genPointerToRecordClassId(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> recordClassIdTbaaNode)
    block.store(toStore, recordClassIdPtr, metadata=allMetadata)
  }

  def genLoadFromRecordClassId(block: IrBlockBuilder)(valueCell: IrValue, metadata: Map[String, Metadata] = Map()): IrValue = {
    val recordClassIdPtr = genPointerToRecordClassId(block)(valueCell)
    val allMetadata = Map("tbaa" -> recordClassIdTbaaNode, "invariant.load" -> GlobalDefines.emptyMetadataNode) ++ metadata
    block.load("recordClassId")(recordClassIdPtr, metadata=allMetadata)
  }

  def genPointerToRecordData(block: IrBlockBuilder)(valueCell: IrValue): IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("recordDataPtr")(
      elementType=recordDataIrType,
      basePointer=valueCell,
      indices=recordDataGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToRecordData(block: IrBlockBuilder)(toStore: IrValue, valueCell: IrValue, metadata: Map[String, Metadata] = Map())  {
    val recordDataPtr = genPointerToRecordData(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> recordDataTbaaNode)
    block.store(toStore, recordDataPtr, metadata=allMetadata)
  }

  def genLoadFromRecordData(block: IrBlockBuilder)(valueCell: IrValue, metadata: Map[String, Metadata] = Map()): IrValue = {
    val recordDataPtr = genPointerToRecordData(block)(valueCell)
    val allMetadata = Map("tbaa" -> recordDataTbaaNode) ++ metadata
    block.load("recordData")(recordDataPtr, metadata=allMetadata)
  }
}

object RecordLikeCell extends CellType with RecordLikeFields {
  val llvmName = "recordLike"
  val irType = UserDefinedType("recordLike")
  val schemeName = "<record-like>"
  val directSubtypes = Set[CellType](ProcedureCell, RecordCell)

  val typeIdGepIndices = List(0, 0, 0)
  val gcStateGepIndices = List(0, 0, 1)
  val dataIsInlineGepIndices = List(0, 1)
  val isUndefinedGepIndices = List(0, 2)
  val recordClassIdGepIndices = List(0, 3)
  val recordDataGepIndices = List(0, 4)

  val typeIdTbaaNode = NumberedMetadata(60L)
  val gcStateTbaaNode = NumberedMetadata(61L)
  val dataIsInlineTbaaNode = NumberedMetadata(62L)
  val isUndefinedTbaaNode = NumberedMetadata(63L)
  val recordClassIdTbaaNode = NumberedMetadata(64L)
  val recordDataTbaaNode = NumberedMetadata(65L)

  def createConstant(dataIsInline: Long, isUndefined: Long, recordClassId: Long, recordData: IrConstant, typeId: Long): StructureConstant = {
    if (recordData.irType != recordDataIrType) {
      throw new InternalCompilerErrorException("Unexpected type for field recordData")
    }

    StructureConstant(List(
      AnyCell.createConstant(typeId=typeId),
      IntegerConstant(dataIsInlineIrType, dataIsInline),
      IntegerConstant(isUndefinedIrType, isUndefined),
      IntegerConstant(recordClassIdIrType, recordClassId),
      recordData
    ), userDefinedType=Some(irType))
  }
}

sealed trait ProcedureFields extends RecordLikeFields {
  val irType: FirstClassType

  val extraDataIrType = ArrayType(8, IntegerType(8))
  val extraDataTbaaNode: Metadata
  val extraDataGepIndices: List[Int]

  val entryPointIrType = PointerType(IntegerType(8))
  val entryPointTbaaNode: Metadata
  val entryPointGepIndices: List[Int]

  def genPointerToExtraData(block: IrBlockBuilder)(valueCell: IrValue): IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("extraDataPtr")(
      elementType=extraDataIrType,
      basePointer=valueCell,
      indices=extraDataGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToExtraData(block: IrBlockBuilder)(toStore: IrValue, valueCell: IrValue, metadata: Map[String, Metadata] = Map())  {
    val extraDataPtr = genPointerToExtraData(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> extraDataTbaaNode)
    block.store(toStore, extraDataPtr, metadata=allMetadata)
  }

  def genLoadFromExtraData(block: IrBlockBuilder)(valueCell: IrValue, metadata: Map[String, Metadata] = Map()): IrValue = {
    val extraDataPtr = genPointerToExtraData(block)(valueCell)
    val allMetadata = Map("tbaa" -> extraDataTbaaNode) ++ metadata
    block.load("extraData")(extraDataPtr, metadata=allMetadata)
  }

  def genPointerToEntryPoint(block: IrBlockBuilder)(valueCell: IrValue): IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("entryPointPtr")(
      elementType=entryPointIrType,
      basePointer=valueCell,
      indices=entryPointGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToEntryPoint(block: IrBlockBuilder)(toStore: IrValue, valueCell: IrValue, metadata: Map[String, Metadata] = Map())  {
    val entryPointPtr = genPointerToEntryPoint(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> entryPointTbaaNode)
    block.store(toStore, entryPointPtr, metadata=allMetadata)
  }

  def genLoadFromEntryPoint(block: IrBlockBuilder)(valueCell: IrValue, metadata: Map[String, Metadata] = Map()): IrValue = {
    val entryPointPtr = genPointerToEntryPoint(block)(valueCell)
    val allMetadata = Map("tbaa" -> entryPointTbaaNode, "invariant.load" -> GlobalDefines.emptyMetadataNode) ++ metadata
    block.load("entryPoint")(entryPointPtr, metadata=allMetadata)
  }
}

object ProcedureCell extends ConcreteCellType with ProcedureFields {
  val llvmName = "procedure"
  val irType = UserDefinedType("procedure")
  val schemeName = "<procedure>"
  val directSubtypes = Set[CellType]()

  val typeId = 12L

  val typeIdGepIndices = List(0, 0, 0, 0)
  val gcStateGepIndices = List(0, 0, 0, 1)
  val dataIsInlineGepIndices = List(0, 0, 1)
  val isUndefinedGepIndices = List(0, 0, 2)
  val recordClassIdGepIndices = List(0, 0, 3)
  val recordDataGepIndices = List(0, 0, 4)
  val extraDataGepIndices = List(0, 1)
  val entryPointGepIndices = List(0, 2)

  val typeIdTbaaNode = NumberedMetadata(66L)
  val gcStateTbaaNode = NumberedMetadata(67L)
  val dataIsInlineTbaaNode = NumberedMetadata(68L)
  val isUndefinedTbaaNode = NumberedMetadata(69L)
  val recordClassIdTbaaNode = NumberedMetadata(70L)
  val recordDataTbaaNode = NumberedMetadata(71L)
  val extraDataTbaaNode = NumberedMetadata(72L)
  val entryPointTbaaNode = NumberedMetadata(73L)

  def createConstant(extraData: IrConstant, entryPoint: IrConstant, dataIsInline: Long, isUndefined: Long, recordClassId: Long, recordData: IrConstant): StructureConstant = {
    if (extraData.irType != extraDataIrType) {
      throw new InternalCompilerErrorException("Unexpected type for field extraData")
    }

    if (entryPoint.irType != entryPointIrType) {
      throw new InternalCompilerErrorException("Unexpected type for field entryPoint")
    }

    StructureConstant(List(
      RecordLikeCell.createConstant(dataIsInline=dataIsInline, isUndefined=isUndefined, recordClassId=recordClassId, recordData=recordData, typeId=typeId),
      extraData,
      entryPoint
    ), userDefinedType=Some(irType))
  }
}

sealed trait RecordFields extends RecordLikeFields {
  val irType: FirstClassType

  val extraDataIrType = ArrayType(16, IntegerType(8))
  val extraDataTbaaNode: Metadata
  val extraDataGepIndices: List[Int]

  def genPointerToExtraData(block: IrBlockBuilder)(valueCell: IrValue): IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("extraDataPtr")(
      elementType=extraDataIrType,
      basePointer=valueCell,
      indices=extraDataGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToExtraData(block: IrBlockBuilder)(toStore: IrValue, valueCell: IrValue, metadata: Map[String, Metadata] = Map())  {
    val extraDataPtr = genPointerToExtraData(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> extraDataTbaaNode)
    block.store(toStore, extraDataPtr, metadata=allMetadata)
  }

  def genLoadFromExtraData(block: IrBlockBuilder)(valueCell: IrValue, metadata: Map[String, Metadata] = Map()): IrValue = {
    val extraDataPtr = genPointerToExtraData(block)(valueCell)
    val allMetadata = Map("tbaa" -> extraDataTbaaNode) ++ metadata
    block.load("extraData")(extraDataPtr, metadata=allMetadata)
  }
}

object RecordCell extends ConcreteCellType with RecordFields {
  val llvmName = "record"
  val irType = UserDefinedType("record")
  val schemeName = "<record>"
  val directSubtypes = Set[CellType]()

  val typeId = 13L

  val typeIdGepIndices = List(0, 0, 0, 0)
  val gcStateGepIndices = List(0, 0, 0, 1)
  val dataIsInlineGepIndices = List(0, 0, 1)
  val isUndefinedGepIndices = List(0, 0, 2)
  val recordClassIdGepIndices = List(0, 0, 3)
  val recordDataGepIndices = List(0, 0, 4)
  val extraDataGepIndices = List(0, 1)

  val typeIdTbaaNode = NumberedMetadata(74L)
  val gcStateTbaaNode = NumberedMetadata(75L)
  val dataIsInlineTbaaNode = NumberedMetadata(76L)
  val isUndefinedTbaaNode = NumberedMetadata(77L)
  val recordClassIdTbaaNode = NumberedMetadata(78L)
  val recordDataTbaaNode = NumberedMetadata(79L)
  val extraDataTbaaNode = NumberedMetadata(80L)

  def createConstant(extraData: IrConstant, dataIsInline: Long, isUndefined: Long, recordClassId: Long, recordData: IrConstant): StructureConstant = {
    if (extraData.irType != extraDataIrType) {
      throw new InternalCompilerErrorException("Unexpected type for field extraData")
    }

    StructureConstant(List(
      RecordLikeCell.createConstant(dataIsInline=dataIsInline, isUndefined=isUndefined, recordClassId=recordClassId, recordData=recordData, typeId=typeId),
      extraData
    ), userDefinedType=Some(irType))
  }
}

sealed trait ErrorObjectFields extends AnyFields {
  val irType: FirstClassType

  val categoryIrType = IntegerType(16)
  val categoryTbaaNode: Metadata
  val categoryGepIndices: List[Int]

  val messageIrType = PointerType(UserDefinedType("string"))
  val messageTbaaNode: Metadata
  val messageGepIndices: List[Int]

  val irritantsIrType = PointerType(UserDefinedType("listElement"))
  val irritantsTbaaNode: Metadata
  val irritantsGepIndices: List[Int]

  def genPointerToCategory(block: IrBlockBuilder)(valueCell: IrValue): IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("categoryPtr")(
      elementType=categoryIrType,
      basePointer=valueCell,
      indices=categoryGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToCategory(block: IrBlockBuilder)(toStore: IrValue, valueCell: IrValue, metadata: Map[String, Metadata] = Map())  {
    val categoryPtr = genPointerToCategory(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> categoryTbaaNode)
    block.store(toStore, categoryPtr, metadata=allMetadata)
  }

  def genLoadFromCategory(block: IrBlockBuilder)(valueCell: IrValue, metadata: Map[String, Metadata] = Map()): IrValue = {
    val categoryPtr = genPointerToCategory(block)(valueCell)
    val allMetadata = Map("tbaa" -> categoryTbaaNode, "invariant.load" -> GlobalDefines.emptyMetadataNode) ++ metadata
    block.load("category")(categoryPtr, metadata=allMetadata)
  }

  def genPointerToMessage(block: IrBlockBuilder)(valueCell: IrValue): IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("messagePtr")(
      elementType=messageIrType,
      basePointer=valueCell,
      indices=messageGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToMessage(block: IrBlockBuilder)(toStore: IrValue, valueCell: IrValue, metadata: Map[String, Metadata] = Map())  {
    val messagePtr = genPointerToMessage(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> messageTbaaNode)
    block.store(toStore, messagePtr, metadata=allMetadata)
  }

  def genLoadFromMessage(block: IrBlockBuilder)(valueCell: IrValue, metadata: Map[String, Metadata] = Map()): IrValue = {
    val messagePtr = genPointerToMessage(block)(valueCell)
    val allMetadata = Map("tbaa" -> messageTbaaNode, "invariant.load" -> GlobalDefines.emptyMetadataNode) ++ metadata
    block.load("message")(messagePtr, metadata=allMetadata)
  }

  def genPointerToIrritants(block: IrBlockBuilder)(valueCell: IrValue): IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("irritantsPtr")(
      elementType=irritantsIrType,
      basePointer=valueCell,
      indices=irritantsGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToIrritants(block: IrBlockBuilder)(toStore: IrValue, valueCell: IrValue, metadata: Map[String, Metadata] = Map())  {
    val irritantsPtr = genPointerToIrritants(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> irritantsTbaaNode)
    block.store(toStore, irritantsPtr, metadata=allMetadata)
  }

  def genLoadFromIrritants(block: IrBlockBuilder)(valueCell: IrValue, metadata: Map[String, Metadata] = Map()): IrValue = {
    val irritantsPtr = genPointerToIrritants(block)(valueCell)
    val allMetadata = Map("tbaa" -> irritantsTbaaNode, "invariant.load" -> GlobalDefines.emptyMetadataNode) ++ metadata
    block.load("irritants")(irritantsPtr, metadata=allMetadata)
  }
}

object ErrorObjectCell extends ConcreteCellType with ErrorObjectFields {
  val llvmName = "errorObject"
  val irType = UserDefinedType("errorObject")
  val schemeName = "<error-object>"
  val directSubtypes = Set[CellType]()

  val typeId = 14L

  val typeIdGepIndices = List(0, 0, 0)
  val gcStateGepIndices = List(0, 0, 1)
  val categoryGepIndices = List(0, 1)
  val messageGepIndices = List(0, 2)
  val irritantsGepIndices = List(0, 3)

  val typeIdTbaaNode = NumberedMetadata(81L)
  val gcStateTbaaNode = NumberedMetadata(82L)
  val categoryTbaaNode = NumberedMetadata(83L)
  val messageTbaaNode = NumberedMetadata(84L)
  val irritantsTbaaNode = NumberedMetadata(85L)

  def createConstant(category: Long, message: IrConstant, irritants: IrConstant): StructureConstant = {
    if (message.irType != messageIrType) {
      throw new InternalCompilerErrorException("Unexpected type for field message")
    }

    if (irritants.irType != irritantsIrType) {
      throw new InternalCompilerErrorException("Unexpected type for field irritants")
    }

    StructureConstant(List(
      AnyCell.createConstant(typeId=typeId),
      IntegerConstant(categoryIrType, category),
      message,
      irritants
    ), userDefinedType=Some(irType))
  }
}

sealed trait PortFields extends AnyFields {
  val irType: FirstClassType

  val portIrType = PointerType(IntegerType(8))
  val portTbaaNode: Metadata
  val portGepIndices: List[Int]

  def genPointerToPort(block: IrBlockBuilder)(valueCell: IrValue): IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("portPtr")(
      elementType=portIrType,
      basePointer=valueCell,
      indices=portGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToPort(block: IrBlockBuilder)(toStore: IrValue, valueCell: IrValue, metadata: Map[String, Metadata] = Map())  {
    val portPtr = genPointerToPort(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> portTbaaNode)
    block.store(toStore, portPtr, metadata=allMetadata)
  }

  def genLoadFromPort(block: IrBlockBuilder)(valueCell: IrValue, metadata: Map[String, Metadata] = Map()): IrValue = {
    val portPtr = genPointerToPort(block)(valueCell)
    val allMetadata = Map("tbaa" -> portTbaaNode, "invariant.load" -> GlobalDefines.emptyMetadataNode) ++ metadata
    block.load("port")(portPtr, metadata=allMetadata)
  }
}

object PortCell extends ConcreteCellType with PortFields {
  val llvmName = "port"
  val irType = UserDefinedType("port")
  val schemeName = "<port>"
  val directSubtypes = Set[CellType]()

  val typeId = 15L

  val typeIdGepIndices = List(0, 0, 0)
  val gcStateGepIndices = List(0, 0, 1)
  val portGepIndices = List(0, 1)

  val typeIdTbaaNode = NumberedMetadata(86L)
  val gcStateTbaaNode = NumberedMetadata(87L)
  val portTbaaNode = NumberedMetadata(88L)

  def createConstant(port: IrConstant): StructureConstant = {
    if (port.irType != portIrType) {
      throw new InternalCompilerErrorException("Unexpected type for field port")
    }

    StructureConstant(List(
      AnyCell.createConstant(typeId=typeId),
      port
    ), userDefinedType=Some(irType))
  }
}

sealed trait EofObjectFields extends AnyFields {
  val irType: FirstClassType
}

object EofObjectCell extends PreconstructedCellType with EofObjectFields {
  val llvmName = "eofObject"
  val irType = UserDefinedType("eofObject")
  val schemeName = "<eof-object>"
  val directSubtypes = Set[CellType]()

  val typeId = 16L

  val typeIdGepIndices = List(0, 0, 0)
  val gcStateGepIndices = List(0, 0, 1)

  val typeIdTbaaNode = NumberedMetadata(89L)
  val gcStateTbaaNode = NumberedMetadata(90L)
}

sealed trait MailboxFields extends AnyFields {
  val irType: FirstClassType

  val mailboxIrType = PointerType(IntegerType(8))
  val mailboxTbaaNode: Metadata
  val mailboxGepIndices: List[Int]

  def genPointerToMailbox(block: IrBlockBuilder)(valueCell: IrValue): IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("mailboxPtr")(
      elementType=mailboxIrType,
      basePointer=valueCell,
      indices=mailboxGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToMailbox(block: IrBlockBuilder)(toStore: IrValue, valueCell: IrValue, metadata: Map[String, Metadata] = Map())  {
    val mailboxPtr = genPointerToMailbox(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> mailboxTbaaNode)
    block.store(toStore, mailboxPtr, metadata=allMetadata)
  }

  def genLoadFromMailbox(block: IrBlockBuilder)(valueCell: IrValue, metadata: Map[String, Metadata] = Map()): IrValue = {
    val mailboxPtr = genPointerToMailbox(block)(valueCell)
    val allMetadata = Map("tbaa" -> mailboxTbaaNode, "invariant.load" -> GlobalDefines.emptyMetadataNode) ++ metadata
    block.load("mailbox")(mailboxPtr, metadata=allMetadata)
  }
}

object MailboxCell extends ConcreteCellType with MailboxFields {
  val llvmName = "mailbox"
  val irType = UserDefinedType("mailbox")
  val schemeName = "<mailbox>"
  val directSubtypes = Set[CellType]()

  val typeId = 17L

  val typeIdGepIndices = List(0, 0, 0)
  val gcStateGepIndices = List(0, 0, 1)
  val mailboxGepIndices = List(0, 1)

  val typeIdTbaaNode = NumberedMetadata(91L)
  val gcStateTbaaNode = NumberedMetadata(92L)
  val mailboxTbaaNode = NumberedMetadata(93L)

  def createConstant(mailbox: IrConstant): StructureConstant = {
    if (mailbox.irType != mailboxIrType) {
      throw new InternalCompilerErrorException("Unexpected type for field mailbox")
    }

    StructureConstant(List(
      AnyCell.createConstant(typeId=typeId),
      mailbox
    ), userDefinedType=Some(irType))
  }
}

sealed trait HashMapFields extends AnyFields {
  val irType: FirstClassType

  val datumHashTreeIrType = PointerType(IntegerType(8))
  val datumHashTreeTbaaNode: Metadata
  val datumHashTreeGepIndices: List[Int]

  def genPointerToDatumHashTree(block: IrBlockBuilder)(valueCell: IrValue): IrValue = {
    if (valueCell.irType != PointerType(irType)) {
      throw new InternalCompilerErrorException(s"Unexpected type for cell value. Passed ${valueCell.irType}, expected ${PointerType(irType)}")
    }

    block.getelementptr("datumHashTreePtr")(
      elementType=datumHashTreeIrType,
      basePointer=valueCell,
      indices=datumHashTreeGepIndices.map(IntegerConstant(IntegerType(32), _)),
      inbounds=true
    )
  }

  def genStoreToDatumHashTree(block: IrBlockBuilder)(toStore: IrValue, valueCell: IrValue, metadata: Map[String, Metadata] = Map())  {
    val datumHashTreePtr = genPointerToDatumHashTree(block)(valueCell)
    val allMetadata = metadata ++ Map("tbaa" -> datumHashTreeTbaaNode)
    block.store(toStore, datumHashTreePtr, metadata=allMetadata)
  }

  def genLoadFromDatumHashTree(block: IrBlockBuilder)(valueCell: IrValue, metadata: Map[String, Metadata] = Map()): IrValue = {
    val datumHashTreePtr = genPointerToDatumHashTree(block)(valueCell)
    val allMetadata = Map("tbaa" -> datumHashTreeTbaaNode, "invariant.load" -> GlobalDefines.emptyMetadataNode) ++ metadata
    block.load("datumHashTree")(datumHashTreePtr, metadata=allMetadata)
  }
}

object HashMapCell extends ConcreteCellType with HashMapFields {
  val llvmName = "hashMap"
  val irType = UserDefinedType("hashMap")
  val schemeName = "<hash-map>"
  val directSubtypes = Set[CellType]()

  val typeId = 18L

  val typeIdGepIndices = List(0, 0, 0)
  val gcStateGepIndices = List(0, 0, 1)
  val datumHashTreeGepIndices = List(0, 1)

  val typeIdTbaaNode = NumberedMetadata(94L)
  val gcStateTbaaNode = NumberedMetadata(95L)
  val datumHashTreeTbaaNode = NumberedMetadata(96L)

  def createConstant(datumHashTree: IrConstant): StructureConstant = {
    if (datumHashTree.irType != datumHashTreeIrType) {
      throw new InternalCompilerErrorException("Unexpected type for field datumHashTree")
    }

    StructureConstant(List(
      AnyCell.createConstant(typeId=typeId),
      datumHashTree
    ), userDefinedType=Some(irType))
  }
}

