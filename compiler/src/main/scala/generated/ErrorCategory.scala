package io.llambda.compiler


// This file is automatically generated by generate-error-categories.scm. Do not edit manually.

sealed abstract class ErrorCategory(val runtimeId: Int)

object ErrorCategory {
  object Default extends ErrorCategory(0)
  object File extends ErrorCategory(1)
  object Read extends ErrorCategory(2)
  object Type extends ErrorCategory(3)
  object Arity extends ErrorCategory(4)
  object Range extends ErrorCategory(5)
  object Utf8 extends ErrorCategory(6)
  object DivideByZero extends ErrorCategory(7)
  object MutateLiteral extends ErrorCategory(8)
  object UndefinedVariable extends ErrorCategory(9)
  object OutOfMemory extends ErrorCategory(10)
  object InvalidArgument extends ErrorCategory(11)
  object IntegerOverflow extends ErrorCategory(12)
  object ImplementationRestriction extends ErrorCategory(13)
  object UnclonableValue extends ErrorCategory(14)
  object NoActor extends ErrorCategory(15)
  object ExpiredEscapeProcedure extends ErrorCategory(16)
  object AskTimeout extends ErrorCategory(17)
  object Match extends ErrorCategory(18)

  def fromPredicate: PartialFunction[String, ErrorCategory] = {
    case "default-error?" => Default
    case "file-error?" => File
    case "read-error?" => Read
    case "type-error?" => Type
    case "arity-error?" => Arity
    case "range-error?" => Range
    case "utf8-error?" => Utf8
    case "divide-by-zero-error?" => DivideByZero
    case "mutate-literal-error?" => MutateLiteral
    case "undefined-variable-error?" => UndefinedVariable
    case "out-of-memory-error?" => OutOfMemory
    case "invalid-argument-error?" => InvalidArgument
    case "integer-overflow-error?" => IntegerOverflow
    case "implementation-restriction-error?" => ImplementationRestriction
    case "unclonable-value-error?" => UnclonableValue
    case "no-actor-error?" => NoActor
    case "expired-escape-procedure-error?" => ExpiredEscapeProcedure
    case "ask-timeout-error?" => AskTimeout
    case "match-error?" => Match
  }
}
